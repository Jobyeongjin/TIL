# Callback

> 자바스크립트는 기본적으로 **동기적(한 번에 하나의 일을 처리)으로 진행**

<br>

## 기본 실행 순서

```jsx
function a() {
	for (let i = 0; i < 100000000000000000; i++);
  return 1;
}

function b() {
  return a() + 1;
}

function c() {
  return b() + 1;
}

const result = c();
console.log(result);
```

 코드는 위에서부터 순차적으로 읽고 내려온다. A, B, C 함수가 선언된 것을 확인하고, C 함수를 실행하게 되는데 C 함수의 결과 값을 가져오기 위해서는 C 함수 안에서 실행된 B 함수의 결과 값이 필요하게 된다. 마찬가지로 B 함수는 A 함수의 결과 값을 요구한다.

 **호출하는 순서(C → B → A 순) 그대로 콜스택에 저장**이 되고, **값을 가져올 때는 반대(A → B → C 순)로, 순차적으로 값을 리턴**한다. 

 여기서 A 함수가 값을 처리하는 데에 시간이 오래 걸리게 된다면 B 와 C 함수는 그 시간만큼 기다리게 되니, 위에 코드와 같이 무거운 로직을 처리하는데 코드가 동기적으로 진행된다면 비효율적인 코드라고 볼 수 있겠다.

<br>

## 비동기

특정 코드의 연산이 끝날 때까지 `코드의 실행을 멈추지 않고 다음 코드를 먼저 실행`

```jsx
function execute() {
  console.log('1');
  setTimeout(() => {
    console.log('2');
  }, 3000);
  console.log('3');
};
execute();
```

 결과부터 보자면 함수를 호출시 1 → 3 → 2 순으로 출력된다. 1을 출력하고 난 뒤, `setTimeout(콜백함수)` 을 만나면 함수를 다른 환경으로 던지고 바로 다음 코드를 실행하게 된다. 위에 코드는 3초 뒤에 2를 출력하는 코드이니, 3초 타이머가 끝나면 콜스택이 비어있는지 확인 후 코드를 실행한다. 

---

#### 참조👇
[CallBack](https://ko.javascript.info/callbacks)